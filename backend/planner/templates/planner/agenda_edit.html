{% extends "planner/base_planner.html" %}
{% block content %}
<style>
    .row-overlap {
        background: #fff2f2 !important;
    }

    .time-invalid {
        border-color: #dc3545 !important;
    }
</style>

<div class="d-flex align-items-center justify-content-between mb-3">
    <h4 class="mb-0">Edit Agenda — {{ date }}</h4>
    <div>
        <button type="submit" form="agendaForm" class="btn btn-primary">Save</button>
        <a href="/agenda" class="btn btn-outline-secondary">Cancel</a>
    </div>
</div>

<!-- Hidden alert; we’ll toggle it via JS -->
<div id="overlapAlert" class="alert alert-danger d-none" role="alert">
    Overlapping tasks detected. Please fix the highlighted rows before saving.
</div>

<div class="row g-4">
    <div class="col-lg-7">
        <form id="agendaForm" method="post">
            {% csrf_token %}
            <input type="hidden" name="items_json" id="items_json">
            <div class="card">
                <div class="card-header">Today’s timeline</div>
                <div class="card-body p-0">
                    <table class="table mb-0 align-middle" id="timelineTable">
                        <thead class="table-light">
                            <tr>
                                <th style="width:20%">Start</th>
                                <th style="width:20%">End</th>
                                <th>Task</th>
                                <th style="width:1%"></th>
                            </tr>
                        </thead>
                        <tbody id="timelineBody">
                            {% for it in items %}
                            <tr data-item-id="{{ it.id }}" data-task-id="{{ it.task.id }}">
                                <td><input class="form-control form-control-sm" value="{{ it.start_hhmm }}"></td>
                                <td><input class="form-control form-control-sm" value="{{ it.end_hhmm }}"></td>
                                <td>{{ it.task.title }} <small class="text-muted">[{{ it.group_name }}]</small></td>
                                <td><button type="button" class="btn btn-sm btn-outline-danger"
                                        onclick="removeRow(this)">✕</button></td>
                            </tr>
                            {% endfor %}
                        </tbody>

                    </table>
                </div>
            </div>
        </form>
    </div>

    <div class="col-lg-5">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <span>Tasklist</span>
                <div class="d-flex gap-2">
                    <select id="groupFilter" class="form-select form-select-sm">
                        <option value="">All groups</option>
                        {% for g in groups %}
                        <option value="{{ g.id }}">{{ g.name }}</option>
                        {% endfor %}
                    </select>
                    <input id="searchBox" class="form-control form-control-sm" placeholder="Search title">
                </div>
            </div>
            <div class="list-group list-group-flush" id="taskList" style="max-height:480px;overflow:auto">
                {% for t in tasks %}
                <button type="button"
                    class="list-group-item list-group-item-action d-flex justify-content-between align-items-center"
                    data-task-id="{{ t.id }}" data-group-id="{{ t.group.id }}" data-duration="{{ t.duration_min }}">
                    <div>
                        <div class="fw-semibold">{{ t.title }}</div>
                        <small class="text-muted">
                            [{{ t.group.name }}] • {{ t.duration_min }}m • P{{ t.priority }} •
                            {{ t.get_desired_time_display|default:t.desired_time }}
                        </small>

                    </div>
                    <span class="btn btn-sm btn-outline-primary">Add</span>
                </button>
                {% endfor %}
            </div>
            <div class="card-footer text-end">
                <a class="btn btn-sm btn-outline-success" href="/agenda/add/task/">+ New Task</a>
                <a class="btn btn-sm btn-outline-secondary" href="/agenda/add/group/">+ New Group</a>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    const taskButtons = Array.from(document.querySelectorAll('#taskList .list-group-item'));
    const groupFilter = document.getElementById('groupFilter');
    const searchBox = document.getElementById('searchBox');
    const body = document.getElementById('timelineBody');
    const itemsInput = document.getElementById('items_json');
    const form = document.getElementById('agendaForm');

    // --- time utils ---
    function parseHHMM(s) {
        if (!s || !/^\d{2}:\d{2}$/.test(s)) return null;
        const [h, m] = s.split(':').map(x => parseInt(x, 10));
        if (h < 0 || h > 24 || m < 0 || m > 59) return null;
        return h * 60 + m;
    }
    function fmt(mm) {
        mm = Math.max(0, Math.min(24 * 60, mm | 0));
        const h = Math.floor(mm / 60), m = mm % 60;
        return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
    }
    function addMin(hhmm, delta) {
        const base = typeof hhmm === 'number' ? hhmm : parseHHMM(hhmm);
        if (base == null) return null;
        return fmt(base + delta);
    }

    // Keep track of the end time of the last *added* row
    let lastAddedEnd = (() => {
        // if there are existing rows, start from the last row's end
        const rows = Array.from(document.querySelectorAll('#timelineBody tr'));
        if (rows.length) {
            const last = rows[rows.length - 1];
            const endVal = last.querySelectorAll('input')[1].value;
            const endMin = parseHHMM(endVal);
            if (endMin != null) return fmt(endMin);
        }
        return "00:00";
    })();


    taskButtons.forEach(btn => btn.addEventListener('click', () => addTaskRow(btn)));

    function addTaskRow(btn) {
        const taskId = btn.getAttribute('data-task-id');
        const title = btn.querySelector('.fw-semibold').innerText.trim();
        const dur = parseInt(btn.getAttribute('data-duration') || '60', 10);

        const start = lastAddedEnd || "00:00";
        const end = addMin(start, dur) || "00:00";

        const row = document.createElement('tr');
        row.setAttribute('data-task-id', taskId);
        row.innerHTML = `
    <td><input class="form-control form-control-sm" value="${start}"></td>
    <td><input class="form-control form-control-sm" value="${end}"></td>
    <td>${title}</td>
    <td><button type="button" class="btn btn-sm btn-outline-danger" onclick="removeRow(this)">✕</button></td>`;
        body.appendChild(row);

        // update chaining anchor based on the *added* row
        lastAddedEnd = end;

        // attach listeners so manual edits also trigger sorting
        attachTimeListeners(row);

        // auto-sort by start time now that a row is added
        sortRowsByStart();
    }




    function removeRow(el) {
        const tr = el.closest('tr');
        const isLast = (tr === body.lastElementChild);
        tr.remove();
        // If we removed the last DOM row, recompute anchor from new last row; otherwise keep lastAddedEnd as-is
        if (isLast) {
            const rows = Array.from(document.querySelectorAll('#timelineBody tr'));
            lastAddedEnd = rows.length
                ? rows[rows.length - 1].querySelectorAll('input')[1].value
                : "00:00";
        }
    }

    (function initSort() {
        const rows = Array.from(document.querySelectorAll('#timelineBody tr'));
        rows.forEach(attachTimeListeners);
        sortRowsByStart();
    })();


    // filters
    groupFilter.addEventListener('change', applyFilter);
    searchBox.addEventListener('input', applyFilter);
    function applyFilter() {
        const gid = groupFilter.value;
        const q = searchBox.value.toLowerCase();
        taskButtons.forEach(btn => {
            const matchesGroup = !gid || btn.getAttribute('data-group-id') === gid;
            const matchesText = !q || btn.innerText.toLowerCase().includes(q);
            btn.style.display = (matchesGroup && matchesText) ? '' : 'none';
        });
    }

    // serialize rows to JSON before submit
    form.addEventListener('submit', (e) => {
        const rows = Array.from(document.querySelectorAll('#timelineBody tr'));
        const items = rows.map((tr, idx) => {
            const inputs = tr.querySelectorAll('input');
            return {
                item_id: tr.getAttribute('data-item-id') || null,
                task_id: tr.getAttribute('data-task-id'),
                start: inputs[0].value,
                end: inputs[1].value,
                order: idx
            };
        });
        console.log('[editor] serializing', items.length, 'row(s):', items);
        itemsInput.value = JSON.stringify(items);
    });






    // --- helpers to read/sort by time ---
    function rowTimes(tr) {
        const [startInput, endInput] = tr.querySelectorAll('input');
        const s = parseHHMM(startInput.value);
        const e = parseHHMM(endInput.value);
        return { s: s ?? 0, e: e ?? 0 };
    }

    function sortRowsByStart() {
        const rows = Array.from(document.querySelectorAll('#timelineBody tr'));
        rows.sort((a, b) => {
            const ta = rowTimes(a), tb = rowTimes(b);
            if (ta.s !== tb.s) return ta.s - tb.s;         // primary: start time
            if (ta.e !== tb.e) return ta.e - tb.e;         // tie-breaker: end time
            // final tie-breaker: keep stable by DOM position (no change)
            return 0;
        });
        // Re-append in sorted order
        rows.forEach(r => body.appendChild(r));
    }

    // When any time field changes, re-sort
    function attachTimeListeners(tr) {
        tr.querySelectorAll('input').forEach(inp => {
            inp.addEventListener('change', sortRowsByStart);
            inp.addEventListener('blur', sortRowsByStart);
        });
    }







    // --- overlap validation helpers ---
    function parseHHMMStrict(s) {
        const m = /^(\d{2}):(\d{2})$/.exec(s || "");
        if (!m) return null;
        const h = +m[1], mi = +m[2];
        if (h < 0 || h > 24 || mi < 0 || mi > 59) return null;
        return h * 60 + mi;
    }

    function collectRows() {
        const rows = Array.from(document.querySelectorAll('#timelineBody tr'));
        return rows.map(tr => {
            const ins = tr.querySelectorAll('input');
            const sV = ins[0].value, eV = ins[1].value;
            const s = parseHHMMStrict(sV), e = parseHHMMStrict(eV);
            return { tr, start: s, end: e, sV, eV };
        });
    }

    function clearRowStyles(rows) {
        rows.forEach(r => {
            r.tr.classList.remove('row-overlap');
            const ins = r.tr.querySelectorAll('input');
            ins[0].classList.remove('time-invalid');
            ins[1].classList.remove('time-invalid');
        });
    }

    function validateOverlaps(showUI = true) {
        const rows = collectRows();
        clearRowStyles(rows);
        const alertBox = document.getElementById('overlapAlert');
        const saveBtn = document.getElementById('saveBtn');

        let hasError = false;

        // invalid times or inverted intervals
        rows.forEach(r => {
            if (r.start == null || r.end == null || r.end <= r.start) {
                hasError = true;
                if (showUI) {
                    r.tr.classList.add('row-overlap');
                    const ins = r.tr.querySelectorAll('input');
                    ins[0].classList.add('time-invalid');
                    ins[1].classList.add('time-invalid');
                }
            }
        });

        // sort by start and check pairwise overlaps
        const sorted = rows.slice().sort((a, b) => (a.start ?? 0) - (b.start ?? 0));
        for (let i = 1; i < sorted.length; i++) {
            const prev = sorted[i - 1], cur = sorted[i];
            if (prev.start != null && prev.end != null && cur.start != null && cur.end != null) {
                if (cur.start < prev.end) { // overlap
                    hasError = true;
                    if (showUI) {
                        prev.tr.classList.add('row-overlap');
                        cur.tr.classList.add('row-overlap');
                    }
                }
            }
        }

        if (showUI) {
            alertBox.classList.toggle('d-none', !hasError);
            if (saveBtn) saveBtn.disabled = hasError;
        }
        return !hasError;
    }

    // Hook into time inputs so edits re-validate
    function attachTimeListeners(tr) {
        tr.querySelectorAll('input').forEach(inp => {
            inp.addEventListener('input', () => validateOverlaps(true));
            inp.addEventListener('change', () => validateOverlaps(true));
            inp.addEventListener('blur', () => validateOverlaps(true));
        });
    }

    // When adding/removing rows, also re-validate
    const _origAddTaskRow = addTaskRow;
    addTaskRow = function (btn) {
        _origAddTaskRow(btn);
        // attach to the newly-added last row (after your add)
        const last = document.querySelector('#timelineBody tr:last-child');
        if (last) attachTimeListeners(last);
        // resort (you already call sort), then validate
        validateOverlaps(true);
    }

    const _origRemoveRow = removeRow;
    removeRow = function (el) {
        _origRemoveRow(el);
        validateOverlaps(true);
    }

    // Prevent submit if overlaps remain
    form.addEventListener('submit', (e) => {
        if (!validateOverlaps(true)) {
            e.preventDefault();
            e.stopPropagation();
        }
    });

    // Initial pass on page load
    (function initValidation() {
        const rows = Array.from(document.querySelectorAll('#timelineBody tr'));
        rows.forEach(attachTimeListeners);
        validateOverlaps(true);
    })();


</script>
{% endblock %}